1  Функция A*(start, goal, f)
2      # множество уже пройденных вершин
3      var closed := the empty set
4      # множество частных решений
5      var open := make_queue(f)
6      enqueue(open, path(start))
7      Пока open не пусто
8          var p := remove_first(open) # извлекаем первое значение из open
9          var x := последняя вершина в p # p - path\путь
10         если x в closed
11             продолжить # если уже в closed игнорируем вершину и 
12         #переходим к след. итерации
13         если x равен goal
14             вернуть p
15         добавить(closed, x) # отмечаем, что х уже пройдена, 
16           #добавляя в closed
17         # добавляем смежные вершины
18         для каждого y в преемниках(x) # для каждой смежной вершины
19             enqueue(open, add_to_path(p, y)) # добавляем вершину в путь 
20             # и новый путь помещаем в open
21     return failure